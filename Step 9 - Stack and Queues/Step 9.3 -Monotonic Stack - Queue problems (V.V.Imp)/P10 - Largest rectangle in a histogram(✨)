Problem Link:-
https://leetcode.com/problems/largest-rectangle-in-histogram/description/
https://www.geeksforgeeks.org/problems/maximum-rectangular-area-in-a-histogram-1587115620/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Brute Force Solution:- For each element, find how many elements are smaller than or equal to itself before and after it in continuation and find the area of 
rectangle that it creates and keep storing the max of them and return max Area at the end.

Code:-
class Solution {
    public int largestRectangleArea(int[] arr) {
        int maxArea = Integer.MIN_VALUE;
        int n =arr.length;
        int area=0,cnt=0,j=0;

        for(int i=0;i<n;i++)
        {
            cnt=0;
            j=i-1;
            while(j>=0&&arr[j]>=arr[i])
            {
                cnt++;
                j--;
            }

            j=i+1;
            while(j<n&&arr[j]>=arr[i])
            {
                cnt++;
                j++;
            }
            cnt++;

            area = cnt*arr[i];

            maxArea=Math.max(area,maxArea);
        }

        return maxArea;
    }
}

T.C. -> O(N^2)
S.C. -> O(1)

Better Solution:- We use the concept of PSE and NSE. Create 2 arrays having previous smaller element and next smaller element for ech element and then traverse the
array and find the area that each element can create, compare it with max and store it as answer.

Code:-
class Solution {
    public int largestRectangleArea(int[] heights) {

        int pse[] = findPSE(heights);
        int nse[] = findNSE(heights);

        int max = Integer.MIN_VALUE;
        for(int i=0;i<heights.length;i++)
        {
            max=Math.max(max,(nse[i]-pse[i]-1)*heights[i]);
        }
        return max;
    }

    public int[] findPSE(int arr[])
    {
        int n=arr.length;
        int ans[] = new int[n];
        Stack<Integer> st = new Stack<>();

        for(int i=0;i<n;i++)
        {
            while(!st.isEmpty()&&arr[st.peek()]>=arr[i])
            {
                st.pop();
            }
            ans[i]=st.isEmpty()?-1:st.peek();
            st.push(i);
        }
        return ans;
    }


    public int[] findNSE(int arr[])
    {
        int n=arr.length;
        int ans[] = new int[n];
        Stack<Integer> st = new Stack<>();

        for(int i=n-1;i>=0;i--)
        {
            while(!st.isEmpty()&&arr[st.peek()]>=arr[i])
            {
                st.pop();
            }
            ans[i]=st.isEmpty()?n:st.peek();
            st.push(i);
        }
        return ans;
    }
}

T.C. -> O(5N)
S.C. -> O(4N)

Therefore, it is a 2-pass solution.

Optimal Solution:- One-pass solution...

Approach:-
