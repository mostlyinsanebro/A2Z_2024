Problem Link:-
https://leetcode.com/problems/rotate-list/


Brute Force Solution:- Put the Linked List in an array, rotate it and put elements back to the LL and return the head.
Code:-
class Solution {
    public ListNode rotateRight(ListNode head, int k) {

        if(head==null) return head;
        ArrayList<Integer> al = new ArrayList<>();

        ListNode temp=head;
        int n=0;
        while(temp!=null)
        {
            al.add(temp.val);
            n++;
            temp=temp.next;
        }

        k=k%n;

        reverse(al,0,al.size()-k-1);  ~ T.C. -> O(N-k)
        reverse(al,al.size()-k,al.size()-1); ~ T.C. -> O(k)
        reverse(al,0,al.size()-1); ~ T. . -> O(N)

        temp=head;
        int i=0;
        while(temp!=null)
        {
            temp.val=al.get(i);
            temp=temp.next;
            i++;
        }
        return head;
    }

    public static void reverse(ArrayList<Integer> al,int l, int r)
    {
        int temp=-0;
        while(l<r)
        {
            temp=al.get(l);
            al.set(l,al.get(r));
            al.set(r,temp);
            l++;
            r--;
        }
    }
}

T.C. -> O(2N)
S.C. -> O(N) ~ for using extra array.


Optimal Solution:- Use the concept of fast and slow pointers here. First make fast go to kth index and then start to increase both slow and fast by one..
when fast reaches last node, break link b/w slow and slow.next and make link of fast with head and return slow's next as new head.

Code:-
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return head;
        int len=1,i=1;
        ListNode temp=head;

        while(temp.next!=null)
        {
            len++;
            temp=temp.next;
        }
        if(k%len==0) return head;

        temp.next=head;

        k = k%len;

        temp=head;
        while(i!=len-k)
        {
            i++;
            temp=temp.next;
        }

        ListNode newHead=temp.next;
        temp.next=null;
        return newHead;

    }
}

T.C. -> O(N+k)
S.C. -> O(1)
